<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · AbstractFFTs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AbstractFFTs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#FFT-and-FFT-planning-functions"><span>FFT and FFT planning functions</span></a></li><li><a class="tocitem" href="#Adjoint-functionality"><span>Adjoint functionality</span></a></li></ul></li><li><a class="tocitem" href="../implementations/">Implementations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Interface"><a class="docs-heading-anchor" href="#Public-Interface">Public Interface</a><a id="Public-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Interface" title="Permalink"></a></h1><h2 id="FFT-and-FFT-planning-functions"><a class="docs-heading-anchor" href="#FFT-and-FFT-planning-functions">FFT and FFT planning functions</a><a id="FFT-and-FFT-planning-functions-1"></a><a class="docs-heading-anchor-permalink" href="#FFT-and-FFT-planning-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fft" href="#AbstractFFTs.fft"><code>AbstractFFTs.fft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fft(A [, dims])</code></pre><p>Performs a multidimensional FFT of the array <code>A</code>. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <code>Base.nextprod</code>. See also <a href="#AbstractFFTs.plan_fft"><code>plan_fft()</code></a> for even greater efficiency.</p><p>A one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by</p><p class="math-container">\[\operatorname{DFT}(A)[k] =
  \sum_{n=1}^{\operatorname{length}(A)}
  \exp\left(-i\frac{2\pi
  (n-1)(k-1)}{\operatorname{length}(A)} \right) A[n].\]</p><p>A multidimensional FFT simply performs this operation along each transformed dimension of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L545-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fft!" href="#AbstractFFTs.fft!"><code>AbstractFFTs.fft!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fft!(A [, dims])</code></pre><p>Same as <a href="#AbstractFFTs.fft"><code>fft</code></a>, but operates in-place on <code>A</code>, which must be an array of complex floating-point numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.ifft" href="#AbstractFFTs.ifft"><code>AbstractFFTs.ifft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ifft(A [, dims])</code></pre><p>Multidimensional inverse FFT.</p><p>A one-dimensional inverse FFT computes</p><p class="math-container">\[\operatorname{IDFT}(A)[k] = \frac{1}{\operatorname{length}(A)}
\sum_{n=1}^{\operatorname{length}(A)} \exp\left(+i\frac{2\pi (n-1)(k-1)}
{\operatorname{length}(A)} \right) A[n].\]</p><p>A multidimensional inverse FFT simply performs this operation along each transformed dimension of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L162-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.ifft!" href="#AbstractFFTs.ifft!"><code>AbstractFFTs.ifft!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ifft!(A [, dims])</code></pre><p>Same as <a href="#AbstractFFTs.ifft"><code>ifft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.bfft" href="#AbstractFFTs.bfft"><code>AbstractFFTs.bfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bfft(A [, dims])</code></pre><p>Similar to <a href="#AbstractFFTs.ifft"><code>ifft</code></a>, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than <a href="#AbstractFFTs.ifft"><code>ifft</code></a> because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)</p><p class="math-container">\[\operatorname{BDFT}(A)[k] = \operatorname{length}(A) \operatorname{IDFT}(A)[k]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L187-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.bfft!" href="#AbstractFFTs.bfft!"><code>AbstractFFTs.bfft!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bfft!(A [, dims])</code></pre><p>Same as <a href="#AbstractFFTs.bfft"><code>bfft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_fft" href="#AbstractFFTs.plan_fft"><code>AbstractFFTs.plan_fft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Pre-plan an optimized FFT along given dimensions (<code>dims</code>) of arrays matching the shape and type of <code>A</code>.  (The first two arguments have the same meaning as for <a href="#AbstractFFTs.fft"><code>fft</code></a>.) Returns an object <code>P</code> which represents the linear operator computed by the FFT, and which contains all of the information needed to compute <code>fft(A, dims)</code> quickly.</p><p>To apply <code>P</code> to an array <code>A</code>, use <code>P * A</code>; in general, the syntax for applying plans is much like that of matrices.  (A plan can only be applied to arrays of the same size as the <code>A</code> for which the plan was created.)  You can also apply a plan with a preallocated output array <code>Â</code> by calling <code>mul!(Â, plan, A)</code>.  (For <code>mul!</code>, however, the input array <code>A</code> must be a complex floating-point array like the output <code>Â</code>.) You can compute the inverse-transform plan by <code>inv(P)</code> and apply the inverse plan with <code>P \ Â</code> (the inverse plan is cached and reused for subsequent calls to <code>inv</code> or <code>\</code>), and apply the inverse plan to a pre-allocated output array <code>A</code> with <code>ldiv!(A, P, Â)</code>.</p><p>The <code>flags</code> argument is a bitwise-or of FFTW planner flags, defaulting to <code>FFTW.ESTIMATE</code>. e.g. passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.  The optional <code>timelimit</code> argument specifies a rough upper bound on the allowed planning time, in seconds. Passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> may cause the input array <code>A</code> to be overwritten with zeros during plan creation.</p><p><a href="#AbstractFFTs.plan_fft!"><code>plan_fft!</code></a> is the same as <a href="#AbstractFFTs.plan_fft"><code>plan_fft</code></a> but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). <a href="#AbstractFFTs.plan_ifft"><code>plan_ifft</code></a> and so on are similar but produce plans that perform the equivalent of the inverse transforms <a href="#AbstractFFTs.ifft"><code>ifft</code></a> and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L102-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_ifft" href="#AbstractFFTs.plan_ifft"><code>AbstractFFTs.plan_ifft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_ifft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Same as <a href="#AbstractFFTs.plan_fft"><code>plan_fft</code></a>, but produces a plan that performs inverse transforms <a href="#AbstractFFTs.ifft"><code>ifft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_bfft" href="#AbstractFFTs.plan_bfft"><code>AbstractFFTs.plan_bfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_bfft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Same as <a href="#AbstractFFTs.plan_fft"><code>plan_fft</code></a>, but produces a plan that performs an unnormalized backwards transform <a href="#AbstractFFTs.bfft"><code>bfft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_fft!" href="#AbstractFFTs.plan_fft!"><code>AbstractFFTs.plan_fft!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_fft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Same as <a href="#AbstractFFTs.plan_fft"><code>plan_fft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_ifft!" href="#AbstractFFTs.plan_ifft!"><code>AbstractFFTs.plan_ifft!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Same as <a href="#AbstractFFTs.plan_ifft"><code>plan_ifft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_bfft!" href="#AbstractFFTs.plan_bfft!"><code>AbstractFFTs.plan_bfft!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Same as <a href="#AbstractFFTs.plan_bfft"><code>plan_bfft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.rfft" href="#AbstractFFTs.rfft"><code>AbstractFFTs.rfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rfft(A [, dims])</code></pre><p>Multidimensional FFT of a real array <code>A</code>, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with <a href="#AbstractFFTs.fft"><code>fft</code></a>. If <code>A</code> has size <code>(n_1, ..., n_d)</code>, the result has size <code>(div(n_1,2)+1, ..., n_d)</code>.</p><p>The optional <code>dims</code> argument specifies an iterable subset of one or more dimensions of <code>A</code> to transform, similar to <a href="#AbstractFFTs.fft"><code>fft</code></a>. Instead of (roughly) halving the first dimension of <code>A</code> in the result, the <code>dims[1]</code> dimension is (roughly) halved in the same way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L141-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.irfft" href="#AbstractFFTs.irfft"><code>AbstractFFTs.irfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">irfft(A, d [, dims])</code></pre><p>Inverse of <a href="#AbstractFFTs.rfft"><code>rfft</code></a>: for a complex array <code>A</code>, gives the corresponding real array whose FFT yields <code>A</code> in the first half. As for <a href="#AbstractFFTs.rfft"><code>rfft</code></a>, <code>dims</code> is an optional subset of dimensions to transform, defaulting to <code>1:ndims(A)</code>.</p><p><code>d</code> is the length of the transformed real array along the <code>dims[1]</code> dimension, which must satisfy <code>div(d,2)+1 == size(A,dims[1])</code>. (This parameter cannot be inferred from <code>size(A)</code> since both <code>2*size(A,dims[1])-2</code> as well as <code>2*size(A,dims[1])-1</code> are valid sizes for the transformed real array.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L318-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.brfft" href="#AbstractFFTs.brfft"><code>AbstractFFTs.brfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">brfft(A, d [, dims])</code></pre><p>Similar to <a href="#AbstractFFTs.irfft"><code>irfft</code></a> but computes an unnormalized inverse transform (similar to <a href="#AbstractFFTs.bfft"><code>bfft</code></a>), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L332-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_rfft" href="#AbstractFFTs.plan_rfft"><code>AbstractFFTs.plan_rfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_rfft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Pre-plan an optimized real-input FFT, similar to <a href="#AbstractFFTs.plan_fft"><code>plan_fft</code></a> except for <a href="#AbstractFFTs.rfft"><code>rfft</code></a> instead of <a href="#AbstractFFTs.fft"><code>fft</code></a>. The first two arguments, and the size of the transformed result, are the same as for <a href="#AbstractFFTs.rfft"><code>rfft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L572-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_brfft" href="#AbstractFFTs.plan_brfft"><code>AbstractFFTs.plan_brfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Pre-plan an optimized real-input unnormalized transform, similar to <a href="#AbstractFFTs.plan_rfft"><code>plan_rfft</code></a> except for <a href="#AbstractFFTs.brfft"><code>brfft</code></a> instead of <a href="#AbstractFFTs.rfft"><code>rfft</code></a>. The first two arguments and the size of the transformed result, are the same as for <a href="#AbstractFFTs.brfft"><code>brfft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L581-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.plan_irfft" href="#AbstractFFTs.plan_irfft"><code>AbstractFFTs.plan_irfft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf)</code></pre><p>Pre-plan an optimized inverse real-input FFT, similar to <a href="#AbstractFFTs.plan_rfft"><code>plan_rfft</code></a> except for <a href="#AbstractFFTs.irfft"><code>irfft</code></a> and <a href="#AbstractFFTs.brfft"><code>brfft</code></a>, respectively. The first three arguments have the same meaning as for <a href="#AbstractFFTs.irfft"><code>irfft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L358-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fftdims" href="#AbstractFFTs.fftdims"><code>AbstractFFTs.fftdims</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fftdims(p::Plan)</code></pre><p>Return an iterable of the dimensions that are transformed by the FFT plan <code>p</code>.</p><p><strong>Implementation</strong></p><p>For legacy reasons, the default definition of <code>fftdims</code> returns <code>p.region</code>. Hence this method should be implemented only for <code>Plan</code> subtypes that do not store the transformed dimensions in a field named <code>region</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fftshift" href="#AbstractFFTs.fftshift"><code>AbstractFFTs.fftshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fftshift(x, [dim])</code></pre><p>Circular-shift along the given dimension of a periodic signal <code>x</code> centered at index <code>1</code> so it becomes centered at index <code>N÷2+1</code>, where <code>N</code> is the size of that dimension.</p><p>This can be undone with <a href="#AbstractFFTs.ifftshift"><code>ifftshift</code></a>. For even <code>N</code> this is equivalent to swapping the first and second halves, so <code>fftshift</code> and <a href="#AbstractFFTs.ifftshift"><code>ifftshift</code></a> are the same.</p><p>If <code>dim</code> is not given then the signal is shifted along each dimension.</p><p>The output of <code>fftshift</code> is allocated. If one desires to store the output in a preallocated array, use <a href="#AbstractFFTs.fftshift!"><code>fftshift!</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L379-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fftshift!" href="#AbstractFFTs.fftshift!"><code>AbstractFFTs.fftshift!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fftshift!(dest, src, [dim])</code></pre><p>Nonallocating version of <a href="#AbstractFFTs.fftshift"><code>fftshift</code></a>. Stores the result of the shift of the <code>src</code> array into the <code>dest</code> array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.ifftshift" href="#AbstractFFTs.ifftshift"><code>AbstractFFTs.ifftshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ifftshift(x, [dim])</code></pre><p>Circular-shift along the given dimension of a periodic signal <code>x</code> centered at index <code>N÷2+1</code> so it becomes centered at index <code>1</code>, where <code>N</code> is the size of that dimension.</p><p>This undoes the effect of <a href="#AbstractFFTs.fftshift"><code>fftshift</code></a>. For even <code>N</code> this is equivalent to swapping the first and second halves, so <a href="#AbstractFFTs.fftshift"><code>fftshift</code></a> and <code>ifftshift</code> are the same.</p><p>If <code>dim</code> is not given then the signal is shifted along each dimension.</p><p>The output of <code>ifftshift</code> is allocated. If one desires to store the output in a preallocated array, use <a href="#AbstractFFTs.ifftshift!"><code>ifftshift!</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L408-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.ifftshift!" href="#AbstractFFTs.ifftshift!"><code>AbstractFFTs.ifftshift!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ifftshift!(dest, src, [dim])</code></pre><p>Nonallocating version of <a href="#AbstractFFTs.ifftshift"><code>ifftshift</code></a>. Stores the result of the shift of the <code>src</code> array into the <code>dest</code> array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L398-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fftfreq" href="#AbstractFFTs.fftfreq"><code>AbstractFFTs.fftfreq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fftfreq(n, fs=1)</code></pre><p>Return the discrete Fourier transform (DFT) sample frequencies for a DFT of length <code>n</code>. The returned <code>Frequencies</code> object is an <code>AbstractVector</code> containing the frequency bin centers at every sample point. <code>fs</code> is the sampling rate of the input signal, which is the reciprocal of the sample spacing.</p><p>Given a window of length <code>n</code> and a sampling rate <code>fs</code>, the frequencies returned are</p><pre><code class="language-julia">[0:n÷2-1; -n÷2:-1]  * fs/n   # if n is even
[0:(n-1)÷2; -(n-1)÷2:-1]  * fs/n  # if n is odd</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; fftfreq(4, 1)
4-element Frequencies{Float64}:
  0.0
  0.25
 -0.5
 -0.25

julia&gt; fftfreq(5, 2)
5-element Frequencies{Float64}:
  0.0
  0.4
  0.8
 -0.8
 -0.4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L470-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.rfftfreq" href="#AbstractFFTs.rfftfreq"><code>AbstractFFTs.rfftfreq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rfftfreq(n, fs=1)</code></pre><p>Return the discrete Fourier transform (DFT) sample frequencies for a real DFT of length <code>n</code>. The returned <code>Frequencies</code> object is an <code>AbstractVector</code> containing the frequency bin centers at every sample point. <code>fs</code> is the sampling rate of the input signal, which is the reciprocal of the sample spacing.</p><p>Given a window of length <code>n</code> and a sampling rate <code>fs</code>, the frequencies returned are</p><pre><code class="language-julia">[0:n÷2;]  * fs/n  # if n is even
[0:(n-1)÷2;]  * fs/n  # if n is odd</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Nyquist-frequency component is considered to be positive, unlike <a href="#AbstractFFTs.fftfreq"><code>fftfreq</code></a>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rfftfreq(4, 1)
3-element Frequencies{Float64}:
 0.0
 0.25
 0.5

julia&gt; rfftfreq(5, 2)
3-element Frequencies{Float64}:
 0.0
 0.4
 0.8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L505-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">size(p::Plan, [dim])</code></pre><p>Return the size of the input of a plan <code>p</code>, optionally at a specified dimenion <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L13-L17">source</a></section></article><h2 id="Adjoint-functionality"><a class="docs-heading-anchor" href="#Adjoint-functionality">Adjoint functionality</a><a id="Adjoint-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Adjoint-functionality" title="Permalink"></a></h2><p>The following API is supported by plans that support adjoint functionality. It is also relevant to implementers of FFT plans that wish to support adjoints.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.adjoint</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.AdjointStyle" href="#AbstractFFTs.AdjointStyle"><code>AbstractFFTs.AdjointStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFFTs.AdjointStyle(::Plan)</code></pre><p>Return the adjoint style of a plan, enabling automatic computation of adjoint plans via <a href="@ref"><code>Base.adjoint</code></a>. Instructions for supporting adjoint styles are provided in the <a href="../implementations/#Defining-a-new-implementation">implementation instructions</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L593-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.adjoint_mul" href="#AbstractFFTs.adjoint_mul"><code>AbstractFFTs.adjoint_mul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">adjoint_mul(p::Plan, x::AbstractArray)</code></pre><p>Multiply an array <code>x</code> by the adjoint of a plan <code>p</code>. This is equivalent to <code>p&#39; * x</code>.</p><p>Implementations of a new adjoint style <code>AS &lt;: AbstractFFTs.AdjointStyle</code> should define <code>adjoint_mul(::Plan, ::AbstractArray, ::AS)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L675-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.FFTAdjointStyle" href="#AbstractFFTs.FFTAdjointStyle"><code>AbstractFFTs.FFTAdjointStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FFTAdjointStyle()</code></pre><p>Adjoint style for complex to complex discrete Fourier transforms that normalize the output analogously to <a href="#AbstractFFTs.fft"><code>fft</code></a>.</p><p>Since the Fourier transform is unitary up to a scaling, the adjoint simply applies  the transform&#39;s inverse with an appropriate scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L602-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.RFFTAdjointStyle" href="#AbstractFFTs.RFFTAdjointStyle"><code>AbstractFFTs.RFFTAdjointStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RFFTAdjointStyle()</code></pre><p>Adjoint style for real to complex discrete Fourier transforms that halve one of the output&#39;s dimensions and normalize the output analogously to <a href="#AbstractFFTs.rfft"><code>rfft</code></a>.</p><p>Since the Fourier transform is unitary up to a scaling, the adjoint applies the transform&#39;s  inverse, but with appropriate scaling and additional logic to handle the fact that the output is projected to exploit its conjugate symmetry (see <a href="#AbstractFFTs.rfft"><code>rfft</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L613-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.IRFFTAdjointStyle" href="#AbstractFFTs.IRFFTAdjointStyle"><code>AbstractFFTs.IRFFTAdjointStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IRFFTAdjointStyle(d::Dim)</code></pre><p>Adjoint style for complex to real discrete Fourier transforms that expect an input with a halved dimension and normalize the output analogously to <a href="#AbstractFFTs.irfft"><code>irfft</code></a>, where <code>d</code> is the original length of the dimension.</p><p>Since the Fourier transform is unitary up to a scaling, the adjoint applies the transform&#39;s  inverse, but with appropriate scaling and additional logic to handle the fact that the input is projected to exploit its conjugate symmetry (see <a href="#AbstractFFTs.irfft"><code>irfft</code></a>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L625-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.UnitaryAdjointStyle" href="#AbstractFFTs.UnitaryAdjointStyle"><code>AbstractFFTs.UnitaryAdjointStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnitaryAdjointStyle()</code></pre><p>Adjoint style for unitary transforms, whose adjoint equals their inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMath/AbstractFFTs.jl/blob/9109f24cab1c05eebc0802ed40b41017c3b1ea62/src/definitions.jl#L640-L644">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../implementations/">Implementations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 7 May 2024 01:50">Tuesday 7 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
